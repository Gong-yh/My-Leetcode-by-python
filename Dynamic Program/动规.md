# Dynamic Program
## 动规五部曲：
		1. DP数组
		2. 递推公式
        3. DP数组初始化
        4. 遍历顺序
		5. 出现问题，打印数组
		
### E 509 斐波那契数列
#### 方法1：创建整个DP数组
```python
class Solution:
    def fib(self, n: int) -> int:
        '''
        动规解题五部曲：
            1. DP数
            2. 递推公式
            3. DP数组初始化
            4. 遍历顺序
            5. 出现问题，打印数组
        '''
        if n == 0:
            return 0
        Dp = [0 for _ in range(n+1)]
        Dp[1] = 1
        for i in range(2,n):
            Dp[i] = Dp[i-1] + Dp[i-2]
        return Dp[n-1] + Dp[n-2]
```
#### 方法2 只维护两个数值
```python 
class Solution:
    def fib(self, n: int) -> int:
        '''
        动规解题五部曲：
            1. DP数
            2. 递推公式
            3. DP数组初始化
            4. 遍历顺序
            5. 出现问题，打印数组
        '''
        # 发现，只需要维护两个数值就好了，不需要记录一整个list
        if n == 0:
            return 0
        Dp = [0,0]
        Dp[0] = 0
        Dp[1] = 1
        for i in range(n-1):
            a = Dp[1]
            Dp[1] +=Dp[0]
            Dp[0] = a
        return Dp[1]
``` 

#### 方法3 递归解法
```python
class Solution:
    def fib(self, n: int) -> int:
        '''
        动规解题五部曲：
            1. DP数
            2. 递推公式
            3. DP数组初始化
            4. 遍历顺序
            5. 出现问题，打印数组
        '''
                # 还可以用递归求解
        if n <2:return n
        return self.fib(n-1) + self.fib(n-2)
```

### E 70 爬楼梯
```python
class Solution:
    def climbStairs(self, n: int) -> int:
        '''
        动规解题五部曲：
            1. DP数  意义
            2. 递推公式
            3. DP数组初始化
            4. 遍历顺序
            5. 出现问题，打印数组
        '''
        if n <= 1:
            return n

        # 递推公式：
           # 第三层 = 第二层+1 / 第一层+2
           # f(n) = f(n-1)+f(n-2)  
        Dp = [0 for _ in range(n)]
        Dp[0] = 1
        Dp[1] = 2
        for  i in range(2,n):
            Dp[i] = Dp[i-1]+Dp[i-2]
        print(Dp)
        return Dp[n-1]

```
###### 就是斐波那契，优化方法和 509一样

#### 拓展
###### 若对于每阶有1……m种迈法呢？
	想法就是对于但前的F(n) = F(n-1) + F(n-2) + …… + F(n-m)